import logging
import time
import math
from datetime import datetime
from Configuration import *
from CameraHead import *
from MessageBroker import *
import RPi.GPIO as GPIO
from Adafruit_MotorHAT import *
import Adafruit_ADS1x15

class Dolly:
	LINEAR         = 0
	ANGULAR        = 1
	LINEARANGLULAR = 2
	LOCKLINEAR     = 3
	LOCKANGLULAR   = 4
	I2CBUS         = 1
	endGPIO        = 26
	startGPIO      = 21
	enc1GPIO       = 19
	enc2GPIO       = 13
	encTick        = (0,0.0)

	def __init__(self, configuration,motorhat):
		# create a default object, no changes to I2C address or frequency
		GPIO.setmode(GPIO.BCM)
		GPIO.setup(self.endGPIO,   GPIO.IN, pull_up_down=GPIO.PUD_UP)
		GPIO.setup(self.startGPIO, GPIO.IN, pull_up_down=GPIO.PUD_UP)
		GPIO.setup(self.enc1GPIO, GPIO.IN, pull_up_down=GPIO.PUD_UP)
		GPIO.setup(self.enc2GPIO, GPIO.IN, pull_up_down=GPIO.PUD_UP)
		GPIO.add_event_detect(self.endGPIO,   GPIO.FALLING, callback=self.endCallback, bouncetime=300)
		GPIO.add_event_detect(self.startGPIO, GPIO.FALLING, callback=self.startCallback, bouncetime=300)
		GPIO.add_event_detect(self.enc1GPIO, GPIO.FALLING, callback=self.enc1Callback, bouncetime=300)
		GPIO.add_event_detect(self.enc2GPIO, GPIO.FALLING, callback=self.enc2Callback, bouncetime=300)
		self.mh = motorhat
		self.config = configuration
		self.running = 0

		self.dollyMotor= self.mh.getMotor(2)      # Linear movement motor
		self.dollyMotor.setSpeed(255)
		
		# 2mm pitch timing belt.
		# Motor speed full throttle 30rpm
		# grey code encoder 12 positions 20 teeth roll => 40mm per rev
		# 3.33mm per tick
		# Speed is (1200mm / minute) -> (20mm / sec) -> (166 msec / tick)
		#
		self.head = CameraHead(self.mh,configuration)
		self.interval = self.config.getDefInterval()

		self.xdist = 0
		self.ydist = 0
		self.mode  = Dolly.LINEAR

		self.atTheEnd = 0
		self.atTheStart = 0

		self.pitch = self.config.getLinearPitch()
		self.teeth = self.config.getLinearTeeth()

		self.declination = 0.0

		self.stepcount = 0
		self.anglecount = 0
		self.numsteps = self.config.getStepsPerFrame()
		self.anglesteps = 0  # steps to rotate camera per frame (used in LocAngular and Anglular modes)
		self.direction = Adafruit_MotorHAT.FORWARD
		self.angleteeth = self.config.getAngularTeeth()
		self.anglestepsperteeth = self.config.getAngularStepsPerTeeth()
		self.initADC()

	def initADC(self):
		self.adc = Adafruit_ADS1x15.ADS1115(address=0x48, busnum=self.I2CBUS)
		self.adc.gain = 1
		self.chanCurr = 0
		self.chanVolt = 1
		self.chanTemp = 2
		self.mvoltage = 3300
		self.adcMAX = 32767
		#self.adc.start_adc(0)

	def quit(self):
		print("Dolly.stop")
		#self.adc.stop_adc()

	def startCallback(self,channel):
		print("falling edge detected on 20")
		self.atTheStart = 1
		self.atTheEnd = 0

	def endCallback(self,channel):
		print("falling edge detected on 26")
		self.atTheStart = 0
		self.atTheEnd = 1

	def enc1Callback(self,channel):
		print("DOLLY enc1Callback")
		ts = self.timestamp()
		if(self.encTick[0] == 2):
			delta = ts-self.encTick[1]
			self.calcSpeed(delta)
		self.encTick = (1,ts)


	def enc2Callback(self,channel):
		print("DOLLY enc2Callback")
		ts = self.timestamp()
		if(self.encTick[0] == 1):
			delta = ts-self.encTick[1]
			calcSpeed(delta*-1)
		self.encTick = (2,ts)

	def calcSpeed(self,ts):
		tick_dist = 40/12 # 20pcs 2mm pitch teeth and 12 position rotary coder
		speed = 
	#recommended for auto-disabling motors on shutdown!
	def turnOffMotors(self):
		kit.stepper1.release()
		kit.stepper2.release()

	def rotateHead(self, speed):
		self.head.rotateHead(speed)

	def moveDolly(self):
		if (self.mode == Dolly.LINEAR):
			self.stepDolly(self.numsteps)
			self.stepcount = self.stepcount+self.numsteps

		if (self.mode == Dolly.ANGULAR):
			print("self.mode == Dolly.ANGULAR")
			self.head.rotateHead(self.anglesteps)
			self.anglecount = self.anglecount+self.anglesteps

		if (self.mode == Dolly.LINEARANGLULAR):
			print("self.mode == Dolly.LINEARANGLULAR")
			self.head.rotateHead(self.anglesteps)
			self.anglecount = self.anglecount+self.anglesteps
			self.stepDolly(self.numsteps)
			self.stepcount = self.stepcount+self.numsteps

		if (self.mode == Dolly.LOCKLINEAR):
			print("self.mode == Dolly.LOCKLINEAR")
			self.stepDolly(self.numsteps)
			anglechange = self.calculateAngularDelta() # radians
			print("LOCKLINEAR anglechange = "+str(anglechange))
			self.head.rotateHead(anglechange)
			self.anglecount = self.anglecount+anglechange
			self.stepcount = self.stepcount+self.numsteps

		if (self.mode == Dolly.LOCKANGLULAR):
			print("self.mode == Dolly.LOCKANGLULAR")
			stepstomove = self.calculateLinearSteps()
			print("LOCKANGLULAR stepstomove = "+str(stepstomove))
			self.stepDolly(stepstomove)
			self.stepcount = self.stepcount+stepstomove
			self.head.rotateHead(self.anglesteps)
			self.anglecount = self.anglecount+self.anglesteps

	def stepDolly(self,steps):
		count = 0
		if (self.direction == Adafruit_MotorHAT.FORWARD and self.atTheEnd == 0):
			print("stepDolly FORWARD")
			while (count < steps):
				self.dollyMotor.run(self.direction)
				#check if GPIO is cleared and clear the flag
				if(GPIO.input(21) is False):
					self.atTheStart = 0
				count = count + 1
				time.sleep(1)
		if (self.direction == Adafruit_MotorHAT.BACKWARD and self.atTheStart == 0):
			print("stepDolly BACKWARD")
			#check if GPIO is cleared and clear the flag
